struct Uniforms {
    viewProjection: mat4x4<f32>,
    deltaTime: f32,
    time: f32,
}

;

struct Instance {
    position: vec3f,
    special: u32
}

;

struct VertexIn {
    @builtin(instance_index) instance: u32,
    @builtin(vertex_index) vertex: u32
}

;

struct VertexOutput {
    @builtin(position) pos: vec4f,
    @location(0) uv: vec2f,
    @location(1) tint: vec3f
}

;

struct Output {
    @location(0) shaded: vec4f,
}

// Pass group
@group(0) @binding(0)
var<uniform> uniforms: Uniforms;
@group(0) @binding(1)
var<storage, read> instances: array<Instance>;
@group(0) @binding(2)
var tBase: texture_2d<f32>;
@group(0) @binding(3)
var sBase: sampler;

const BILLBOARD = array<vec4f, 4>(vec4(- 1.0, - 1.0, 0.0, 0.0), vec4(- 1.0, 1.0, 0.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0), vec4(1.0, - 1.0, 1.0, 0.0));

fn decodeRGBX8(i: u32) -> vec3f {
    return vec3f(vec3((i >> 24) & 0xff, (i >> 16) & 0xff, (i >> 8) & 0xff)) / 256.0;
}

fn getUvPos(special: u32, uvOffset: vec2f) -> vec2f {
    return (vec2f(f32((special >> 3) & 0x7), f32(special & 0x7)) + uvOffset) * 0.125;
}

@vertex
fn vertex_main(input: VertexIn) -> VertexOutput {
    let instance = instances[input.instance];
    let offset = BILLBOARD[input.vertex];
    let transformedPos = uniforms.viewProjection * vec4f(instance.position, 1.0);

    // TODO: per sprite scale
    let scale = f32(((instance.special >> 6) & 0x4) + 1) * 0.25;
    let scaledOffset = offset.xy * scale;

    // TODO: distance scale
    // TODO: index -> UV

    var output: VertexOutput;
    output.pos = transformedPos + vec4(scaledOffset, 0.0, 0.0);
    output.uv = getUvPos(instance.special, offset.zw);
    output.tint = decodeRGBX8(instance.special);
    return output;
}

@fragment
fn fragment_main(input: VertexOutput) -> vec4f {
    return vec4f(0.0, 0.0, 0.0, 0.0);
}